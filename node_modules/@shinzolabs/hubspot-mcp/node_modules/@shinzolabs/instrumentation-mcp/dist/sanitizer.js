"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PIISanitizer = void 0;
const resources_1 = require("@opentelemetry/resources");
class PIISanitizer {
    constructor() {
        this.piiPatterns = [
            /\b\d{4}[\s-]?\d{4}[\s-]?\d{4}[\s-]?\d{4}\b/g, // Credit card numbers
            /\b\d{3}-\d{2}-\d{4}\b/g, // SSN
            /\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b/g, // Email addresses
            /\b\d{3}[\s-]?\d{3}[\s-]?\d{4}\b/g, // Phone numbers
            /\b(?:api[_-]?key|secret|token|password|passwd|pwd)\s*[:=]\s*["']?([^"'\s]+)/gi, // API keys and secrets
            /\b(?:Bearer|Basic)\s+[A-Za-z0-9+/=]+/gi, // Auth headers
        ];
    }
    redactPIIAttributes() {
        return {
            detect: () => new resources_1.Resource({
                'client.address': '[REDACTED]',
                'client.port': '[REDACTED]',
                'host.id': '[REDACTED]',
                'host.name': '[REDACTED]'
            })
        };
    }
    sanitize(data) {
        return this.sanitizeValue(data);
    }
    sanitizeObject(obj) {
        const sanitized = {};
        for (const [key, value] of Object.entries(obj)) {
            if (this.isSensitiveKey(key))
                sanitized[key] = '[REDACTED]';
            else
                sanitized[key] = this.sanitizeValue(value);
        }
        return sanitized;
    }
    sanitizeValue(value) {
        if (typeof value === 'string')
            return this.sanitizeString(value);
        else if (value instanceof Error) {
            const sanitizedError = new Error(this.sanitizeString(value.message));
            sanitizedError.name = value.name;
            sanitizedError.stack = value.stack ? this.sanitizeString(value.stack) : value.stack;
            return sanitizedError;
        }
        else if (typeof value === 'object' && value !== null) {
            return Array.isArray(value)
                ? value.map(item => this.sanitizeValue(item))
                : this.sanitizeObject(value);
        }
        return value;
    }
    sanitizeString(str) {
        let sanitized = str;
        for (const pattern of this.piiPatterns) {
            sanitized = sanitized.replace(pattern, '[REDACTED]');
        }
        return sanitized;
    }
    isSensitiveKey(key) {
        const sensitiveKeys = [
            'password', 'passwd', 'pwd', 'secret', 'token', 'key', 'auth', 'authorization',
            'apikey', 'api_key', 'access_token', 'refresh_token', 'bearer', 'credential',
            'ssn', 'social_security', 'credit_card', 'cc_number', 'cvv', 'pin'
        ];
        return sensitiveKeys.some(sensitiveKey => key.toLowerCase().includes(sensitiveKey));
    }
}
exports.PIISanitizer = PIISanitizer;
//# sourceMappingURL=sanitizer.js.map