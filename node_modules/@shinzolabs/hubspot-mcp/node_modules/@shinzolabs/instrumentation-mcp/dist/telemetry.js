"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TelemetryManager = void 0;
const api_1 = require("@opentelemetry/api");
const sdk_node_1 = require("@opentelemetry/sdk-node");
const resources_1 = require("@opentelemetry/resources");
const semantic_conventions_1 = require("@opentelemetry/semantic-conventions");
const sdk_trace_base_1 = require("@opentelemetry/sdk-trace-base");
const exporter_trace_otlp_http_1 = require("@opentelemetry/exporter-trace-otlp-http");
const exporter_metrics_otlp_http_1 = require("@opentelemetry/exporter-metrics-otlp-http");
const sdk_metrics_1 = require("@opentelemetry/sdk-metrics");
const sdk_trace_base_2 = require("@opentelemetry/sdk-trace-base");
const config_1 = require("./config");
const sanitizer_1 = require("./sanitizer");
const utils_1 = require("./utils");
class TelemetryManager {
    constructor(config) {
        this.isInitialized = false;
        config_1.ConfigValidator.validate(config);
        this.config = { ...config_1.DEFAULT_CONFIG, ...config };
        this.sessionId = (0, utils_1.generateUuid)();
        this.sessionStart = Date.now();
        if (this.config.enablePIISanitization) {
            this.piiSanitizer = config.PIISanitizer || new sanitizer_1.PIISanitizer();
        }
        const resource = new resources_1.Resource({
            [semantic_conventions_1.ATTR_SERVICE_NAME]: this.config.serverName,
            [semantic_conventions_1.ATTR_SERVICE_VERSION]: this.config.serverVersion,
            'mcp.session.id': this.sessionId,
        });
        const sdkConfig = {
            resource,
            resourceDetectors: [
                resources_1.envDetector,
                resources_1.hostDetector,
                resources_1.osDetector,
                resources_1.serviceInstanceIdDetectorSync
            ]
        };
        if (this.piiSanitizer) {
            sdkConfig.resourceDetectors?.push(this.piiSanitizer.redactPIIAttributes());
        }
        if (this.config.enableTracing) {
            sdkConfig.traceExporter = this.createTraceExporter();
            if (this.config.samplingRate !== undefined) {
                sdkConfig.sampler = new sdk_trace_base_1.TraceIdRatioBasedSampler(this.config.samplingRate);
            }
        }
        const metricReader = this.createMetricReader();
        if (this.config.enableMetrics && metricReader) {
            sdkConfig.metricReader = metricReader; // https://github.com/open-telemetry/opentelemetry-js/issues/3944
        }
        this.sdk = new sdk_node_1.NodeSDK(sdkConfig);
        this.sdk.start();
        this.isInitialized = true;
        this.tracer = api_1.trace.getTracer(this.config.serverName, this.config.serverVersion);
        this.meter = api_1.metrics.getMeter(this.config.serverName, this.config.serverVersion);
    }
    getOTLPHeaders() {
        const headers = {};
        if (this.config.exporterAuth) {
            switch (this.config.exporterAuth.type) {
                case 'bearer':
                    headers['Authorization'] = `Bearer ${this.config.exporterAuth.token}`;
                    break;
                case 'apiKey':
                    headers['X-API-Key'] = this.config.exporterAuth.apiKey;
                    break;
                case 'basic': {
                    const encoded = Buffer.from(`${this.config.exporterAuth.username}:${this.config.exporterAuth.password}`).toString('base64');
                    headers['Authorization'] = `Basic ${encoded}`;
                    break;
                }
            }
        }
        return headers;
    }
    createTraceExporter() {
        if (this.config.exporterType === 'console')
            return new sdk_trace_base_2.ConsoleSpanExporter();
        const headers = this.getOTLPHeaders();
        const url = this.config.exporterEndpoint +
            (this.config.exporterEndpoint?.endsWith('/') ? '' : '/') +
            'traces';
        return new exporter_trace_otlp_http_1.OTLPTraceExporter({ url, headers });
    }
    createMetricReader() {
        if (this.config.exporterType === 'console')
            return undefined; // No metric reader for console output
        const headers = this.getOTLPHeaders();
        const url = this.config.exporterEndpoint +
            (this.config.exporterEndpoint?.endsWith('/') ? '' : '/') +
            'metrics';
        const metricExporter = new exporter_metrics_otlp_http_1.OTLPMetricExporter({ url, headers });
        return new sdk_metrics_1.PeriodicExportingMetricReader({
            exporter: metricExporter,
            exportIntervalMillis: this.config.metricExportIntervalMs || config_1.DEFAULT_CONFIG.metricExportIntervalMs,
            exportTimeoutMillis: this.config.batchTimeoutMs || config_1.DEFAULT_CONFIG.batchTimeoutMs,
        });
    }
    startActiveSpan(name, attributes, fn) {
        if (!this.isInitialized)
            throw new Error('Telemetry not initialized');
        const processedAttributes = this.processTelemetryAttributesWithSessionId(attributes);
        return this.tracer.startActiveSpan(name, { attributes: processedAttributes }, fn);
    }
    createSpan(name, attributes) {
        if (!this.isInitialized)
            throw new Error('Telemetry not initialized');
        const processedAttributes = this.processTelemetryAttributesWithSessionId(attributes);
        return this.tracer.startSpan(name, { attributes: processedAttributes });
    }
    getHistogram(name, options) {
        if (!this.isInitialized)
            throw new Error('Telemetry not initialized');
        const histogram = this.meter.createHistogram(name, options);
        return (value, attributes) => {
            const processedAttributes = this.processTelemetryAttributesWithSessionId(attributes);
            histogram.record(value, processedAttributes);
        };
    }
    getIncrementCounter(name, options) {
        if (!this.isInitialized)
            throw new Error('Telemetry not initialized');
        const counter = this.meter.createCounter(name, options);
        return (value, attributes) => {
            const processedAttributes = this.processTelemetryAttributesWithSessionId(attributes);
            counter.add(value, processedAttributes);
        };
    }
    getArgumentAttributes(params, prefix = 'mcp.request.argument') {
        if (!this.config.enableArgumentCollection)
            return {};
        const attributes = {};
        const flatten = (obj, path) => {
            for (const key in obj) {
                const value = obj[key];
                const attrKey = `${path}.${key}`;
                if (value && typeof value === 'object' && !Array.isArray(value)) {
                    flatten(value, attrKey);
                }
                else {
                    attributes[attrKey] = value;
                }
            }
        };
        if (params && typeof params === 'object')
            flatten(params, prefix);
        return attributes;
    }
    recordSessionDuration() {
        if (this.config.enableMetrics) {
            const recordHistogram = this.getHistogram('mcp.server.session.duration', {
                description: 'MCP server session duration as observed on the receiver from the time it was received until the session is closed.',
                unit: 's'
            });
            recordHistogram(Date.now() - this.sessionStart, { 'mcp.session.id': this.sessionId });
        }
    }
    processTelemetryAttributesWithSessionId(data) {
        return this.processTelemetryAttributes({ 'mcp.session.id': this.sessionId, ...(data || {}) });
    }
    processTelemetryAttributes(data) {
        let processedData = { ...data };
        if (this.config.dataProcessors) {
            for (const processor of this.config.dataProcessors) {
                processedData = processor(processedData);
            }
        }
        if (this.piiSanitizer) {
            processedData = this.piiSanitizer.sanitize(processedData);
        }
        return processedData;
    }
    async shutdown() {
        this.recordSessionDuration();
        if (this.sdk)
            await this.sdk.shutdown();
    }
}
exports.TelemetryManager = TelemetryManager;
//# sourceMappingURL=telemetry.js.map