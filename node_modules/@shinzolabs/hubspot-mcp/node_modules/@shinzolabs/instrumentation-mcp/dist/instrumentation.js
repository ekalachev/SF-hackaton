"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.McpServerInstrumentation = void 0;
const api_1 = require("@opentelemetry/api");
const utils_1 = require("./utils");
class McpServerInstrumentation {
    constructor(server, telemetryManager) {
        this.isInstrumented = false;
        this.server = server;
        this.telemetryManager = telemetryManager;
    }
    instrument() {
        if (this.isInstrumented)
            return;
        this.instrumentTools();
        this.instrumentCompletions();
        this.instrumentLogs();
        this.instrumentNotifications();
        this.instrumentPings();
        this.instrumentPrompts();
        this.instrumentResources();
        this.instrumentRoots();
        this.instrumentSampling();
        this.isInstrumented = true;
    }
    instrumentTools() {
        if (!this.server.tool || typeof this.server.tool !== 'function') {
            return;
        }
        const originalTool = this.server.tool.bind(this.server);
        this.server.tool = (name, ...rest) => {
            const cb = rest[rest.length - 1];
            if (typeof cb === 'function') {
                rest[rest.length - 1] = this.createInstrumentedHandler(cb, 'tools/call', name);
            }
            return originalTool(name, ...rest);
        };
    }
    instrumentCompletions() {
        // TODO add instrumentation for the completion method
    }
    instrumentLogs() {
        // TODO add instrumentation for the logging method
    }
    instrumentNotifications() {
        // TODO add instrumentation for the notification method
    }
    instrumentPings() {
        // TODO add instrumentation for the ping method
    }
    instrumentPrompts() {
        // TODO add instrumentation for the prompt method
    }
    instrumentResources() {
        // TODO add instrumentation for the resource method
    }
    instrumentRoots() {
        // TODO add instrumentation for the root method
    }
    instrumentSampling() {
        // TODO add instrumentation for the sampling method
    }
    createInstrumentedHandler(originalHandler, method, name) {
        const { address, port } = (0, utils_1.getRuntimeInfo)();
        const baseAttributes = {
            'mcp.method.name': method,
            'mcp.tool.name': name
        };
        const recordHistogram = this.telemetryManager.getHistogram('mcp.server.operation.duration', {
            description: 'MCP request or notification duration as observed on the receiver from the time it was received until the result or ack is sent.',
            unit: 'ms'
        });
        const incrementCounter = this.telemetryManager.getIncrementCounter(`${method} ${name}`, {
            description: 'MCP request or notification count as observed on the receiver.',
            unit: 'calls'
        });
        return async (params) => {
            const spanAttributes = {
                ...baseAttributes,
                'mcp.request.id': (0, utils_1.generateUuid)(),
                'client.address': address,
                ...(port ? { 'client.port': port } : {}),
                ...(this.telemetryManager.getArgumentAttributes(params))
            };
            return this.telemetryManager.startActiveSpan(`${method} ${name}`, spanAttributes, async (span) => {
                incrementCounter(1);
                let result;
                let error;
                const startTime = Date.now();
                try {
                    result = await originalHandler.apply(this.server, [params]);
                    span.setStatus({ code: api_1.SpanStatusCode.OK });
                }
                catch (error) {
                    span.setStatus({ code: api_1.SpanStatusCode.ERROR, message: error.message });
                    span.setAttribute('error.type', error.name);
                }
                const endTime = Date.now();
                const duration = endTime - startTime;
                recordHistogram(duration, {
                    ...baseAttributes,
                    'error.type': error ? error.name : undefined
                });
                span.end();
                if (error)
                    throw error;
                return result;
            });
        };
    }
}
exports.McpServerInstrumentation = McpServerInstrumentation;
//# sourceMappingURL=instrumentation.js.map